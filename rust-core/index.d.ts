/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Basic GameObject information */
export interface GameObject {
  name: string
  fileId: string
  active: boolean
  matchScore?: number | undefined
}
/** Component information */
export interface Component {
  type: string
  classId: number
  fileId: string
  scriptPath?: string | undefined
  scriptGuid?: string | undefined
  scriptName?: string | undefined
  properties?: Record<string, any> | undefined
}
/** GameObject with detailed component information */
export interface GameObjectDetail {
  name: string
  fileId: string
  active: boolean
  tag: string
  layer: number
  depth?: number | undefined
  components: Array<Component>
  children?: string[] | undefined
  parentTransformId?: string | undefined
}
/** PrefabInstance information */
export interface PrefabInstanceInfo {
  name: string
  fileId: string
  sourceGuid: string
  sourcePrefab?: string | undefined
  modificationsCount: number
}
/** A single property override in a PrefabInstance */
export interface PrefabModification {
  targetFileId: string
  targetGuid?: string | undefined
  propertyPath: string
  value: string
}
/** Union result from find_by_name: either a GameObject or PrefabInstance */
export interface FindResult {
  name: string
  fileId: string
  resultType: string
  active?: boolean | undefined
  matchScore?: number | undefined
  sourceGuid?: string | undefined
  sourcePrefab?: string | undefined
  modificationsCount?: number | undefined
}
/** Full scene inspection result */
export interface SceneInspection {
  file: string
  count: number
  gameobjects: Array<GameObjectDetail>
  prefabInstances?: PrefabInstanceInfo[] | undefined
}
/** Options for scanning */
export interface ScanOptions {
  verbose?: boolean | undefined
}
/** Options for inspecting */
export interface InspectOptions {
  file: string
  identifier?: string | undefined
  includeProperties?: boolean | undefined
  verbose?: boolean | undefined
}
/** Pagination options for inspect_all */
export interface PaginationOptions {
  file: string
  includeProperties?: boolean | undefined
  verbose?: boolean | undefined
  pageSize?: number | undefined
  cursor?: number | undefined
  maxDepth?: number | undefined
  filterComponent?: string | undefined
}
/** Paginated inspection result */
export interface PaginatedInspection {
  file: string
  total: number
  totalInScene: number
  cursor: number
  nextCursor?: number | undefined
  truncated: boolean
  pageSize: number
  gameobjects: Array<GameObjectDetail>
  prefabInstances?: PrefabInstanceInfo[] | undefined
  error?: string | undefined
}
/** Chunk types for indexing */
export const enum ChunkType {
  Prose = 'Prose',
  Code = 'Code',
  Api = 'Api',
  Example = 'Example'
}
/** Chunk metadata */
export interface ChunkMetadata {
  filePath: string
  section?: string | undefined
  language?: string | undefined
  unityClass?: string | undefined
  unityMethod?: string | undefined
}
/** A chunk of indexed content */
export interface Chunk {
  id: string
  content: string
  tokens: number
  type: ChunkType
  metadata: ChunkMetadata
}
/** Result of indexing operation */
export interface IndexResult {
  chunksIndexed: number
  totalTokens: number
  filesProcessed: number
  elapsedMs: number
}
/** Search result from index */
export interface SearchResult {
  id: string
  content: string
  score: number
  metadata: ChunkMetadata
}
/**
 * Extract type names from a single .NET DLL.
 *
 * Returns public types with their name and namespace.
 * GUID is always None for DLL types (they have no .meta files).
 */
export declare function extractDllTypes(path: string): Array<CSharpTypeRef>
/**
 * Extract type info with fields from a single .NET DLL.
 *
 * Returns extended type info including serializable fields, base class,
 * and struct/enum distinction via the Extends column.
 */
export declare function extractDllFields(path: string): Array<CSharpTypeInfo>
/** A serializable field extracted from a C# type. */
export interface CSharpFieldRef {
  /** Field name (e.g., "health", "moveSpeed") */
  name: string
  /** C# type name (e.g., "int", "Vector3", "List<string>", "GameObject") */
  typeName: string
  /** Whether [SerializeField] attribute is present */
  hasSerializeField: boolean
  /** Whether [SerializeReference] attribute is present */
  hasSerializeReference: boolean
  /** Whether the field is public */
  isPublic: boolean
  /** Which type this field belongs to (e.g., "PlayerController") */
  ownerType: string
}
/** Extended type info with fields and base class, extracted on demand. */
export interface CSharpTypeInfo {
  /** Type name (e.g., "PlayerController") */
  name: string
  /** Kind: "class", "struct", "enum", or "interface" */
  kind: string
  /** Namespace (e.g., "UnityEngine.UI") */
  namespace?: string
  /** Base class (e.g., "MonoBehaviour", "ScriptableObject") */
  baseClass?: string
  /** Serializable fields */
  fields: Array<CSharpFieldRef>
}
/** A C# type reference extracted from source or DLL. */
export interface CSharpTypeRef {
  /** Type name (e.g., "PlayerController") */
  name: string
  /** Kind: "class", "struct", "enum", or "interface" */
  kind: string
  /** Namespace (e.g., "UnityEngine.UI") */
  namespace?: string
  /** Source file or DLL path (relative to project root) */
  filePath: string
  /** GUID from adjacent .meta file (None for DLL types) */
  guid?: string
}
/**
 * Extract C# type declarations from a single .cs file.
 *
 * Returns all public/internal class, struct, enum, and interface declarations
 * with their namespace context and the GUID from the adjacent .meta file.
 */
export declare function extractCsharpTypes(path: string): Array<CSharpTypeRef>
/**
 * Build a type registry by scanning all .cs files in a Unity project.
 *
 * Scans Assets/ and optionally Library/PackageCache/ for .cs files,
 * extracts type declarations, and returns them with GUID + namespace info.
 * When include_packages is true, also scans Library/PackageCache/.
 * When include_dlls is true, also extracts types from DLLs in Library/ScriptAssemblies/.
 */
export declare function buildTypeRegistry(projectRoot: string, includePackages?: boolean | undefined | null, includeDlls?: boolean | undefined | null): Array<CSharpTypeRef>
/**
 * Extract serialized field info from a single C# source file.
 *
 * Returns extended type info with fields, base class, and serialization attributes.
 * This is called on-demand during component creation, not during registry builds.
 */
export declare function extractSerializedFields(path: string): Array<CSharpTypeInfo>
/**
 * Walk a Unity project and collect files matching the given extensions.
 *
 * Walks `Assets/` (and `ProjectSettings/` when `.asset` is among extensions).
 * Skips standard Unity noise directories (Library, Temp, etc.).
 */
export declare function walkProjectFiles(projectPath: string, extensions: Array<string>, excludeDirs?: Array<string> | undefined | null): Array<string>
export interface NapiGrepOptions {
  projectPath: string
  pattern: string
  fileType?: string
  maxResults?: number
  contextLines?: number
}
export interface NapiGrepMatch {
  file: string
  lineNumber: number
  line: string
  contextBefore?: Array<string>
  contextAfter?: Array<string>
}
export interface NapiGrepResult {
  success: boolean
  projectPath: string
  pattern: string
  totalFilesScanned: number
  totalMatches: number
  truncated: boolean
  matches: Array<NapiGrepMatch>
  error?: string
}
/** Grep across Unity project files in parallel using Rayon. */
export declare function grepProject(options: NapiGrepOptions): NapiGrepResult
/**
 * Build the GUID cache by scanning all .meta files under Assets/ in parallel.
 *
 * Returns a JSON object mapping `{ guid: relative_asset_path }`.
 */
export declare function buildGuidCache(projectRoot: string): any
/**
 * Build a GUID cache for Library/PackageCache/ contents.
 *
 * Scans `Library/PackageCache/` for `.meta` files and returns
 * `{ guid: relative_path }` just like `build_guid_cache` does for Assets/.
 * Returns a separate cache so project assets and package assets stay distinct.
 */
export declare function buildPackageGuidCache(projectRoot: string): any
/** Get the version of the native module */
export declare function getVersion(): string
/** Check if the native module is available */
export declare function isNativeAvailable(): boolean
/** High-performance Unity scene/prefab scanner */
export declare class Scanner {
  constructor()
  /** Add a hierarchy provider class ID (Transform-like components). */
  addHierarchyProvider(classId: number): void
  /** Add a script container class ID (MonoBehaviour-like components). */
  addScriptContainer(classId: number): void
  /** Set project root for GUID resolution */
  setProjectRoot(path: string): void
  /** Scan scene for basic GameObject information */
  scanSceneMinimal(file: string): Array<GameObject>
  /** Scan scene with component information */
  scanSceneWithComponents(file: string, options?: ScanOptions | undefined | null): Array<any>
  /**
   * Scan scene for GO metadata (name, tag, layer) without component/hierarchy extraction.
   * This is the "medium path" â€” faster than scan_scene_with_components for tag/layer filtering.
   */
  scanSceneMetadata(file: string): Array<any>
  /** Find GameObjects and PrefabInstances by name pattern */
  findByName(file: string, pattern: string, fuzzy: boolean): Array<FindResult>
  /** Inspect a specific GameObject */
  inspect(options: InspectOptions): any | null
  /** Inspect entire file */
  inspectAll(file: string, includeProperties: boolean, verbose: boolean): SceneInspection
  /** Inspect entire file with pagination support */
  inspectAllPaginated(options: PaginationOptions): PaginatedInspection
  /** Read a .asset file and return its root objects with properties */
  readAsset(file: string): any
}
/** High-performance documentation indexer */
export declare class Indexer {
  constructor()
  /** Index a single file */
  indexFile(path: string): IndexResult
  /** Index a directory of files */
  indexDirectory(path: string): IndexResult
  /** Search the index */
  search(query: string): Array<SearchResult>
  /** Clear the index */
  clear(): void
  /** Get index statistics */
  stats(): any
}
/**
 * Local CPU embedding generator using all-MiniLM-L6-v2 (384 dims).
 * Wraps fastembed-rs / ONNX Runtime. Model auto-downloads on first use
 * and is cached at ~/.claude/unity-agentic-tools/models/.
 */
export declare class EmbeddingGenerator {
  constructor()
  /** Generate embedding for a single text. Returns a Vec<f64> (384 dims). */
  generate(text: string): Array<number>
  /** Generate embeddings for a batch of texts. Returns Vec<Vec<f64>>. */
  generateBatch(texts: Array<string>): Array<Array<number>>
}
